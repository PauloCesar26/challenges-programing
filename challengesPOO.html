<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Challenges POO</title>
</head>
<body>
    <script>
        // Encapsulamento and Herança
        // Encapsulamento:é o principio de agrupar dados(atributos), metodos(funções) que operam sobre esses dados
            // em uma unica classe principal e ao mesmo tempo restringe o acesso direto aos dados de fora(capsula protetora).
            // Capsula (Agrupamento): classe banckAccount agrupa o que é a conta e o que ela faz, atributos e metodos 
            // Restrição de acesso: o encapsulamento garante que os dados internos do objeto não possam ser alterados de forma incontrolavel
        
        // class bankAccount{
        //     constructor(titular){
        //         this.titular = titular;
        //         this.currentMoney = 0.00;
        //     }

        //     deposit(depositValue){
        //         if(depositValue > 0){
        //             this.currentMoney += depositValue;
        //             return this.currentMoney;
        //         }
        //         else{
        //             return 0;
        //         }
        //     }

        //     withdraw(withdrawValue){
        //         if(withdrawValue > 0 && this.currentMoney > withdrawValue){
        //             this.currentMoney -= withdrawValue; 
        //             return true;
        //         }
        //         else{
        //             return false;
        //         }
        //     }

        //     queryBankAccount(){
        //         return `Titular: ${this.titular} \nCurrent value: ${this.currentMoney}`;
        //     }
        // };

        // class savingMoneyAccount extends bankAccount{
        //     constructor(titular){
        //         super(titular);
        //         this.taxWithdraw = 5.00;
        //     }

        //     withdraw(withdrawValue){
        //         const calculateWithdraw = withdrawValue + this.taxWithdraw;

        //         if(this.currentMoney >= calculateWithdraw){
        //             this.currentMoney -= calculateWithdraw;
        //             console.log("Withdraw succes");
        //             return true;
        //         }
        //         else{
        //             console.log("Withdraw failed");
        //             return false;
        //         }

        //     }
        // };
        
        // const myAccount = new bankAccount("Paulo");
        // console.log(myAccount.currentMoney);
        // console.log(myAccount.deposit(500));
        // console.log(myAccount.deposit(-100));
        // console.log(myAccount.withdraw(200));
        // console.log(myAccount.withdraw(400));
        // console.log(myAccount.queryBankAccount());

        // console.log("----------------------------------------");

        // const myAccountSavingMoney = new savingMoneyAccount("Katia");
        // console.log(myAccountSavingMoney.deposit(100.00));
        // console.log(myAccountSavingMoney.withdraw(20.00));
        // console.log(myAccountSavingMoney.queryBankAccount());
        // console.log(myAccountSavingMoney.withdraw(30.00));


        // _______________________________________________________________________________


        // Associação
        // class address{
        //     constructor(street, numberHouse, city){
        //         this.street = street;
        //         this.numberHouse = numberHouse;
        //         this.city = city;
        //     }

        //     completeAddress(){
        //         return `${this.street}, ${this.numberHouse}, ${this.city}`;
        //     }
        // }

        // class employee{
        //     constructor(name, positionCompany, employeeAddressInstance){
        //         this.name = name;
        //         this.positionCompany = positionCompany;
        //         this.employeeAddress = employeeAddressInstance;
        //     }

        //     displayDetailsComplete(){
        //         const fullAddress = this.employeeAddress.completeAddress();

        //         return `${this.name}\n${this.positionCompany}\n${fullAddress}`;
        //     }
        // };

        // const addressPaulo = new address("Rua y", "157", "São Paulo");        
        // const employeePaulo = new employee("Paulo C.", "Desenvolvedor", addressPaulo);
        // console.log(employeePaulo.displayDetailsComplete());


        // _______________________________________________________________________________


        // Polimorfismo
        // class circulo{
        //     constructor(raio){
        //         this.raio = raio;
        //     }

        //     calculateArea(){
        //         const pi = 3.14;
        //         return pi * this.raio ** 2; 
        //     }
        // }

        // class retangulo{
        //     constructor(width, height){
        //         this.width = width;
        //         this.height = height;
        //     }

        //     calculateArea(){
        //         return this.width * this.height;
        //     }
        // }

        // const circle = new circulo(5);
        // const rectangle = new retangulo(4, 10);

        // const list = [circle, rectangle];
        // for(const item of list){
        //     console.log(item.calculateArea());
        // }

        
        // _______________________________________________________________________________


        // Encapsulamento, Herança and Polimorfismo
        // class vehicle{
        //     constructor(mark, model, consumingByKm){
        //         this.mark = mark;
        //         this.model = model;
        //         this.consumingByKm = consumingByKm;
        //     }

        //     getInfo(){
        //         return `Mark: ${this.mark} \nModel: ${this.model}`;
        //     }

        //     calculateExpenseTravel(distanceByKm, priceFuel){
        //         const expense = (distanceByKm / this.consumingByKm) * priceFuel;

        //         return expense;
        //     }
        // }

        // class car extends vehicle{
        //     constructor(mark, model, consumingByKm){
        //         super(mark, model, consumingByKm);
        //         this.taxToll = 20.00;
        //     }

        //     calculateExpenseTravel(distanceByKm, priceFuel){
        //         const fuelExpense = super.calculateExpenseTravel(distanceByKm, priceFuel);
        //         const totalExpense = fuelExpense + this.taxToll;

        //         return totalExpense;
        //     }
        // }

        // class truck extends vehicle{
        //     constructor(mark, model, consumingByKm, axes){
        //         super(mark, model, consumingByKm);
        //         this.axes = axes;
        //         this.taxByAxe = 5.00;
        //     }

        //     calculateExpenseTravel(distanceByKm, priceFuel){
        //         const fuelExpense = super.calculateExpenseTravel(distanceByKm, priceFuel);
        //         const variableTax = this.axes * this.taxByAxe;
        //         const totalExpense = fuelExpense + variableTax;
                
        //         return totalExpense;
        //     }
        // }

        // const carA = new car("Fiat", "Pulser", 10.0);
        // const truckB = new truck("Volvo", "FH", 3.0, 4);
        // const distance = 300;
        // const price = 6.0;

        // const expenseCar = carA.calculateExpenseTravel(distance, price);
        // const expenseTruck = truckB.calculateExpenseTravel(distance, price);

        // console.log(expenseCar);
        // console.log(expenseTruck);


        // _______________________________________________________________________________

        
        // Check instance of object (instance of)
        // function filterProducts(list){
        //     const instanceClassProduct = list.filter(el => el instanceof product);
        //     return instanceClassProduct;
        // }

        // class product{
        //     constructor(name){
        //         this.name = name;
        //     }
        // }

        // class service{
        //     constructor(description){
        //         this.description = description;
        //     }
        // }

        // const p1 = new product("Phone");
        // const s1 = new service("TI");
        // const p2 = new product("Notebook");
        // const s2 = new service("Consultoria");

        // const listItems = [p1, s1, p2, s2];

        // console.log(filterProducts(listItems));


        // _______________________________________________________________________________


        // Identifier name of class (constructor.name)
        // function getNameClasse(obj){
        //     console.log(obj.constructor.name);
        // }

        // class user{
        //     constructor(id){
        //         this.id = id;
        //     }
        // }

        // class order{
        //     constructor(total){
        //         this.total = total;
        //     }
        // }

        // const user1 = new user(47);
        // const order1 = new order(150.00);

        // getNameClasse(user1);
        // getNameClasse(order1);
       


        // _______________________________________________________________________________


        //Polimorfismo: FontWeb e FontEmail implementam o mesmo method "getMessage"
        //Associação: class CollectinManagerFont associa as instancia de classes 
            //atraves do array "this.listInstances" e do method addFont
        // class FontWeb{
        //     constructor(url){
        //         this.url = url;
        //     }

        //     getMessage(){
        //         return `Message of web: ${this.url}`;
        //     }
        // }

        // class FontEmail{
        //     constructor(email){
        //         this.email = email;
        //     }

        //     getMessage(){
        //         return `Message of email: ${this.email}`;
        //     }
        // }

        // class CollectionManagerFont{
        //     constructor(){
        //         this.listInstances = [];
        //     } 

        //     addFont(font){
        //         this.listInstances.push(font);
        //     }

        //     processMessages(){
        //         const newListWithGetMessages = this.listInstances.map(item => {
        //             return item.getMessage();
        //         });   
                
        //         return newListWithGetMessages;
        //     }
        // }

        // const fontWeb = new FontWeb("blog.com");
        // const fontEmail = new FontEmail("paulo@email.com");

        // const getFonts = new CollectionManagerFont();

        // getFonts.addFont(fontWeb);
        // getFonts.addFont(fontEmail);

        // const messages = getFonts.processMessages();

        // console.log(messages);


        // _______________________________________________________________________________



        // Concepts OOP in the exercise
        // Polimorfismo: FormatText and FormatJson, answer same formatData method with different logics
        // Associação: ReportGenerator class gerencia the collection of objects formatadores (this.listFormats)
        // Inspeção of objects: with content.constructor name === typeFormat para identificar the object correct
        class FormatText{
            formatData(data){
                return data.join("\n");
            }
        }

        class FormatJson{
            formatData(data){
                const processedData = data.map(item => {
                    const [key, value] = item.split(':');
                    return { [key]: value };
                });

                return JSON.stringify(processedData, null, 2);
            }
        }

        class ReportGenerator{
            constructor(){
                this.listFormats = [];
            }

            addFormat(format){
                this.listFormats.push(format)
            }

            reportGenerator(typeFormat, datas){
                for(const content of this.listFormats){
                    if(content.constructor.name === typeFormat){
                        return content.formatData(datas);
                    }
                }

                return `Error: Format ${typeFormat} invalid.`;
            }
        }

        const datasSell = ["Product A: 100", "Product B: 100", "Total: 200"];

        const generator = new ReportGenerator();

        generator.addFormat(new FormatText());
        generator.addFormat(new FormatJson());

        const reportText = generator.reportGenerator("FormatText", datasSell);
        const reportJSON = generator.reportGenerator("FormatJson", datasSell);

        console.log(reportText);
        console.log(reportJSON);

 



















        

    </script>
</body>
</html>